// SPDX-License-Identifier: MIT

// #![allow(dead_code)]

use anyhow::Result;
use std::sync::Arc;
use vulkano::pipeline::graphics::vertex_input::Vertex;
use super::device::Device;

//
// We now create a buffer that will store the shape of our triangle. We use `#[repr(C)]` here
// to force rustc to use a defined layout for our data, as the default representation has *no
// guarantees*.
//
#[derive(vulkano::buffer::BufferContents, vulkano::pipeline::graphics::vertex_input::Vertex)]
#[repr(C)]
pub struct VertexPosition {
    #[format(R32G32_SFLOAT)]
    pub position: [f32; 2],
}

pub struct Pipeline {
    pub handle: Arc<vulkano::pipeline::GraphicsPipeline>,
}

impl Pipeline {
    pub fn create_standard_pipeline(graphics: &Device) -> Result<Self> {
        //
        // The raw shader creation API provided by the vulkano library is unsafe for various reasons,
        // so The `shader!` macro provides a way to generate a Rust module from GLSL source - in the
        // example below, the source is provided as a string input directly to the shader, but a path
        // to a source file can be provided as well. Note that the user must specify the type of shader
        // (e.g. "vertex", "fragment", etc.) using the `ty` option of the macro.
        //
        // The items generated by the `shader!` macro include a `load` function which loads the shader
        // using an input logical device. The module also includes type definitions for layout
        // structures defined in the shader source, for example uniforms and push constants.
        //
        // A more detailed overview of what the `shader!` macro generates can be found in the
        // vulkano-shaders crate docs. You can view them at https://docs.rs/vulkano-shaders/
        mod vs {
            vulkano_shaders::shader! {
                ty: "vertex",
                src: r"
                #version 450

                layout(location = 0) in vec2 position;

                void main() {
                    gl_Position = vec4(position, 0.0, 1.0);
                }
            ",
            }
        }

        mod fs {
            vulkano_shaders::shader! {
                ty: "fragment",
                src: r"
                #version 450

                layout(location = 0) out vec4 f_color;

                void main() {
                    f_color = vec4(1.0, 1.0, 1.0, 1.0);
                }
            ",
            }
        }

        let vs = vs::load(graphics.device.clone()).unwrap();
        let fs = fs::load(graphics.device.clone()).unwrap();

        // create the pipeline
        let pipeline = vulkano::pipeline::GraphicsPipeline::start()
            // We have to indicate which subpass of which render pass this pipeline is going to be used
            // in. The pipeline will only be usable from this particular subpass.
            .render_pass(
                vulkano::render_pass::Subpass::from(graphics.render_pass.clone(), 0).unwrap(),
            )
            // We need to indicate the layout of the vertices.
            .vertex_input_state(VertexPosition::per_vertex())
            // The content of the vertex buffer describes a list of triangles.
            .input_assembly_state(vulkano::pipeline::graphics::input_assembly::InputAssemblyState::new())
            // A shader can in theory contain multiple entry points, so we have to specify which one.
            .vertex_shader(vs.entry_point("main").unwrap(), ())
            // Use a resizable viewport set to draw over the entire window
            .viewport_state(vulkano::pipeline::graphics::viewport::ViewportState::viewport_dynamic_scissor_irrelevant())
            // See `vertex_shader`.
            .fragment_shader(fs.entry_point("main").unwrap(), ())
            // Now that our builder is filled, we call `build()` to obtain an actual pipeline.
            .build(graphics.device.clone())
            .unwrap();

        Ok(Self {
            handle: pipeline.clone(),
        })
    }
}
